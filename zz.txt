%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% How to use writeLaTeX: 
%
% You edit the source code here on the left, and the preview on the
% right shows you the result within a few seconds.
%
% Bookmark this page and share the URL with your co-authors. They can
% edit at the same time!
%
% You can upload figures, bibliographies, custom classes and
% styles using the files menu.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage{xcolor} % to access the named colour LightGray
\usepackage{stackengine}

\definecolor{LightGray}{gray}{0.9}
\usepackage{minted}
\setminted{mathescape, bgcolor=LightGray, baselinestretch=1.1, breaklines,obeytabs=true,breaksymbolleft=, escapeinside=||, linenos}

%\usepackage[brazil]{babel}   
\usepackage[utf8]{inputenc}  
\renewcommand{\theFancyVerbLine}{\sffamily \textcolor [rgb] {0.5,0.5,1.0}{ \small  \oldstylenums{\arabic{FancyVerbLine}}}}

\sloppy

\title{Ordenação por Seleção de Raiz Quadrada\\ Análise de Algoritmos - Projeto 1}

\author{Matheus Nilo Santiago\inst{1}, Reidner Sousa dos Santos\inst{1}}


\address{Instituto Federal de Brasília -- (IFB)\\
  Campus Taguatinga -- Brasília -- DF -- Brasil
}

\begin{document} 

\maketitle

\begin{resumo} 
  Este meta-artigo descreve o estilo a ser usado na confecção de artigos e
  resumos de artigos para publicação nos anais das conferências organizadas
  pela SBC. É solicitada a escrita de resumo e abstract apenas para os artigos
  escritos em português. Artigos em inglês deverão apresentar apenas abstract.
  Nos dois casos, o autor deve tomar cuidado para que o resumo (e o abstract)
  não ultrapassem 10 linhas cada, sendo que ambos devem estar na primeira
  página do artigo.
\end{resumo}


\section{Introdução}


Um dos pontos mais importantes de qualquer algoritmo é a sua eficiência em relação ao tempo de execução para uma dada entrada $n$. A modo mais usado para aferir essa eficiência é analisando a eficiência assintótica do algoritmo.

Nesse artigo, analisaremos a eficiência assintótica de duas implementações do algoritmo de ordenação por seleção de raiz quadrada: a primeira será utilizando o insertion sort, e a segunda será utilizando a estrutura de dados heap.

\section{Ordenação por seleção de raiz quadrada} \label{sec:firstpage}

O método de ordenação por seleção de raiz quadrada (\textit{sqrt\_sort}), de forma breve, consiste em:


\begin{enumerate}
    \item Dividir um vetor de tamanho $n$ em $\lceil\; n/\sqrt{n}\; \rceil$ partes

    \item Econtrar o maior elemento $e_i$ de cada uma das $k$ partes ,$1 \leq i \leq k $
    
    \item Retirar o maior valor do passo anterior de sua respectiva parte e o insere no vetor solução
    
    \item Repetir os passos 2 e 3 até que todas as partes estejam vazias
\end{enumerate}

\textbf{Pergunta pro professor como seria um exemplo para colocar aqui - Eu coloco um desenho do passo a passo?}

Existem diferentes possibilidades de se implementar esse algoritmo. A eficiência de cada uma delas depende do quão rápido os passos 2 e 3 serão executados.

Por exemplo, utilizar o merge sort para realizar o passo 2 seria muito mais eficiente do que se utilizássemos 
o bubble sort, dado uma entrada suficientemente grande. Isso ocorre devido a complexidade de cada algoritmo, sendo a complexidade do merge sort $\Theta(n\log{n})$, e a do bubble sort, $\Theta(n^2)$.



\section{Análise dos Algoritmos}

\subsection{Implementação usando insertion sort}
\hfill
\begin{minted}[highlightlines={4, 7-9, 15-18}]{python}
def sqrt_sort_quadratico(V):
    n = len(V)
    # Divide $V$ em $\lceil\; \sqrt{n}\; \rceil$ partes
    partes = particiona_array(V)   # $\mathbf{\Theta(\sqrt{n})}$              $\mathbf{(1)}$

    # Ordena cada parte usando o insertion sort
    for parte in partes:       # $\mathbf{\Theta(\sqrt{n})}$                  $\mathbf{(2)}$
        insertion_sort(parte)  # $\mathbf{\Theta((\sqrt{n})^2) = \Theta(n)}$
    # $\mathbf{\Theta(\sqrt{n}.n) = \Theta(n^{\frac{3}{2}})}$

    # vetor auxiliar que irá guardar o maior elemento de cada parte
    max_partes = [parte[-1] for parte in partes]
    
    solucao = []
    for _ in range(n):  # $\mathbf{\Theta(n)}$                          $\;\mathbf{(3)}$
        # pega o index do maior elemento entre os maiores
        max_index = np.argmax(max_partes) # $\mathbf{\Theta(\sqrt{n})}$
        # $\mathbf{\Theta(\sqrt{n}.n) = \Theta(n^{\frac{3}{2}})}$

        # parte que contem o maior elemento
        parte = partes[max_index]

        # remove o maior elemento da parte de origem e o adiciona na solucao
        maior_valor = parte.pop()
        solucao.append(maior_valor)

        # Repõe o maior elemento da parte retirada.Se a parte ficou vazia, seta o maior elemento dela como $-\infty$. fazendo com que ela seja ignorada futuramente 
        if len(parte) != 0:
            max_partes[max_index] =  parte[-1] 
        else:
            max_partes[max_index] =  -np.inf

    return solucao
\end{minted}



\subsection{Implementação usando heap}

\begin{minted}[highlightlines={6-8,12-14,20-23}]{python}
def sqrt_sort_heap(V):
    n = len(V)
    # Divide $V$ em $\lceil\; \sqrt{n}\; \rceil$ partes
    partes = particiona_array(V) # $\mathbf{\Theta(\sqrt{n})}$
    
    for parte in partes:  # $\mathbf{\Theta(\sqrt{n})}$                       $\textcolor{black}{\mathbf{(1)}}$
        heapify(parte)    # $\mathbf{O(\sqrt{n})} $
    # $\mathbf{O (\sqrt{n} \cdot \sqrt{n}) = O(n)}$
    
    # heap auxiliar que guarda o menor elemento retirado de cada parte e o index da parte correspondente
    tracked_heap = []
    for idx_parte in range(len(partes)):    # $\mathbf{\Theta(\sqrt{n})}$     $\textcolor{black}{\mathbf{(2)}}$
        value = heappop(partes[idx_parte])  # $\mathbf{O({lg(n)})}$
    # $\mathbf{O(\sqrt{n}\cdot lg(n))}$ 
        t_value = TrackedValue(value, idx_parte)
        tracked_heap.append(t_value)
    heapify(tracked_heap) # $\mathbf{O(\sqrt{n})}$

    solucao = []
    for _ in range(n): # $\mathbf{\Theta(n)}$                           $\;\textcolor{black}{\mathbf{(3)}}$
        # Retira o menor item da heap auxiliar
        tracked_value = heappop(tracked_heap) # $\mathbf{O({lg(n)})}$
    # $\mathbf{O(n \cdot lg(n))}$
        # Adiciona o valor do item na solucao
        solucao.append(tracked_value.value)

        # Atualiza a heap auxiliar com o próximo menor elemento da parte de origem
        parte_origem = partes[tracked_value.idx_parte]
        if len(parte_origem) != 0:
            # Retira o menor elemento da parte
            value = heappop(parte_origem) # $\mathbf{O({lg(n)})}$
            # Adiciona o novo valor rastreado na heap auxiliar
            heappush(tracked_heap, TrackedValue(value, tracked_value.idx_parte)) # $\mathbf{O({lg(n)})}$
    return solucao
\end{minted}



\section{Figures and Captions}\label{sec:figs}


Figure and table captions should be centered if less than one line
(Figure~\ref{fig:exampleFig1}), otherwise justified and indented by 0.8cm on
both margins, as shown in Figure~\ref{fig:exampleFig2}. The caption font must
be Helvetica, 10 point, boldface, with 6 points of space before and after each
caption.

\begin{figure}[ht]
\centering
\includegraphics[width=.5\textwidth]{fig1.jpg}
\caption{A typical figure}
\label{fig:exampleFig1}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=.3\textwidth]{fig2.jpg}
\caption{This figure is an example of a figure caption taking more than one
  line and justified considering margins mentioned in Section~\ref{sec:figs}.}
\label{fig:exampleFig2}
\end{figure}

In tables, try to avoid the use of colored or shaded backgrounds, and avoid
thick, doubled, or unnecessary framing lines. When reporting empirical data,
do not use more decimal digits than warranted by their precision and
reproducibility. Table caption must be placed before the table (see Table 1)
and the font used must also be Helvetica, 10 point, boldface, with 6 points of
space before and after each caption.

\begin{table}[ht]
\centering
\caption{Variables to be considered on the evaluation of interaction
  techniques}
\label{tab:exTable1}
\includegraphics[width=.7\textwidth]{table.jpg}
\end{table}

\section{Images}

All images and illustrations should be in black-and-white, or gray tones,
excepting for the papers that will be electronically available (on CD-ROMs,
internet, etc.). The image resolution on paper should be about 600 dpi for
black-and-white images, and 150-300 dpi for grayscale images.  Do not include
images with excessive resolution, as they may take hours to print, without any
visible difference in the result. 

\section{References}

Bibliographic references must be unambiguous and uniform.  We recommend giving
the author names references in brackets, e.g. \cite{knuth:84},
\cite{boulic:91}, and \cite{smith:99}.

The references must be listed using 12 point font size, with 6 points of space
before each reference. The first line of each reference should not be
indented, while the subsequent should be indented by 0.5 cm.

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
